#include<bits/stdc++.h>
using namespace std;
int a[501000], n;
int dfs()
{
	for(int i = 1; i <= n; ++i)
		if(a[i] & 1)
		{
			if(a[i] == 1) return 0;
			a[i]--;
		}
	int tmp = a[1];
	for(int i = 2; i <= n; ++i)
		tmp = __gcd(a[i], tmp);
	for(int i = 1; i <= n; ++i) 
		a[i] /= tmp;
	int cnt = 0;
	for(int i = 1; i <= n; ++i)
		if(!(a[i] & 1)) cnt++;
	if(cnt & 1) return 0;
	else
	{
		if(n - cnt > 1) return 1;
		else return dfs() ^ 1;
	}

int main()
{
	freopen("gold.in", "r", stdin);
	freopen("gold.out", "w", stdout);
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	int cnt = 0;
	for(int i = 1; i <= n; ++i)
		if(!(a[i] & 1)) cnt ++;
	if(cnt & 1)
		puts("ShichengXiao");
	else 
	{
		if(n - cnt > 1) puts("zhu888");
		else if(dfs()) puts("ShichengXiao");
		else puts("zhu888");
	}
	return 0;
}
/*
题意:
游戏规则如下：他们将金牌分为n堆，每堆有ai块(一开始所有a都互质)，每次一个人选择其中大于一块的一堆，并在其中拿走一块金牌，之后再算出a1-an gcd的值，每一堆只留下ai/gcd块。当下一个人没有办法拿取金牌时，则赢得这场游戏。
求先手还是后手必胜

思路:
由题意可知，只有在数列出现形如k k k ... k + 1时会有人获胜，然而另一个人肯定会让另一个人拿不到这样的序列，而k > 1时，这样的破坏总是可以做到的(随便选一个k减一即可)。所以获胜的条件即为拿到形如1 1 1 ... 2这样的序列。此时序列中有奇数个偶数。

分情况讨论:
1.初始序列有奇数个偶数
此时的状态显然对先手有利,若不考虑除gcd,两个人一轮操作分别拿一个石子,不会对奇偶数量有任何影响.而奇数除以奇数和偶数除以奇数奇偶性均不发生变化,所以后手唯一的希望是想办法除掉一个偶数的gcd来改变对先手有利的状态.
考虑若出现偶数gcd,则所有ai都必须为偶,由于一开始所有都互质,所以必定有一个奇数,所以先手可以不停地制造奇数,虽然后手也在不停地制造偶数,但场上总会有个奇数(一开始那个).
这个状态,先手必胜

2.初始序列有偶数个偶数
显然此时状态对先手不利,显然先手也要翻转这个状态,即除个偶数gcd.
此时场上有至少一个奇数,但由于先手先搞,至少一个奇数并不能保证场上一直有个奇数.
再分情况
(1 有至少两个奇数,此时虽然后手晚一点制造奇数,但仍能保证场上有奇数,后手赢
(2 只有1个奇数,但该数为1,虽然先手想制造偶数,但不能对1减1,所以后手赢
(3 只有1个奇数,该数不为1,此时终于翻转状态了,但我们不能确定之后谁赢谁输,不过直接暴力模拟之后的状态,若出现了上面讨论过的任何一种情况则得到解，否则继续递归下去
这个复杂度由于每次都是在除gcd,是log的

*/
