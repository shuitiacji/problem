#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define mod 1000000007
LL ans;
int main(){
	freopen("table.in","r",stdin);
	freopen("table.out","w",stdout);
	int r,c,minT,maxT;
	scanf("%d%d%d%d",&r,&c,&minT,&maxT);
	for(int i=3;i<=r;++i){
		for(int j=3;j<=c;++j){
			int w=2*(i+j-2);
			if(w<=maxT&&w>=minT)ans+=1LL*(r-i+1)*(c-j+1)*(i-2)*(j-2)%mod;
		}
	}
	cout<<ans*6%mod<<endl;
	return 0;
}

题意：

今天CZY又找到了三个妹子，有着收藏爱好的他想要找三个地方将妹子们藏起来，将一片空地抽象成一个R行C列的表格，CZY要选出3个单元格。但要满足如下的两个条件：

（1）任意两个单元格都不在同一行。

（2）任意两个单元格都不在同一列。

选取格子存在一个花费，而这个花费是三个格子两两之间曼哈顿距离的和（如(x1,y1)和(x,y2)的曼哈顿距离为|x1-x2|+|y1-y2|）。狗狗想知道的是，花费在minT到maxT之间的方案数有多少。

答案模1000000007。所谓的两种不同方案是指：只要它选中的单元格有一个不同，就认为是不同的方案。

思路：
首先对于三个点来说他们的坐标如果交换，对花费没有影响。
所以题意=枚举3个横坐标和三个纵坐标，算合理的方案数。
不妨令x1<x2<x3,y1<y2<y3,所以花费为2(x3-x1)+2(y3-y1)，且方案数乘6即为答案（3个数排列组合一下）
所以可以只枚举2个点。
还可以优化，发现花费公式就是x1,y1;x3,y3构成的矩形周长，没有必要在意点，枚举矩形边长，根据边长推一下有多少这种矩形，同时由于x2,y2可以是矩形中的任意一点，还要乘一下x2,y2的个数。最后乘以6。
