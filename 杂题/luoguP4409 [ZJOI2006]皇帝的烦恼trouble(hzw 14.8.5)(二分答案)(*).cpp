#include<bits/stdc++.h>
using namespace std;
const int maxn=20010;
int a[maxn],maxx[maxn],minx[maxn];
int n;
int ck(int x){
	maxx[1]=minx[1]=a[1];
	for(int i=2;i<=n;++i){
		maxx[i]=min(a[1]-minx[i-1],a[i]);
		minx[i]=max(0,a[i]-(x-a[1]-a[i-1]+maxx[i-1]));
	}
	return !minx[n];
}
int main(){
	freopen("trouble.in","r",stdin);
	freopen("trouble.out","w",stdout);
	int l=0,r=0;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		r+=a[i];
	}
	for(int i=1;i<=n;++i){
		if(i==n)l=max(l,a[i]+a[1]);
		else l=max(l,a[i]+a[i+1]);
	}
	int ans;
	while(l<=r){
		int mid=(l+r)>>1;
		if(ck(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans<<endl;
	return 0;
}
/*
题意:
经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置n名将军。不幸的是这n名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。

秦皇已经准备好了秘密处决这些无礼的边防大将。

不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第i个将军要求得到ai枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为i的将军和编号为i+1的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号1和编号n的将军也相邻）。

皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？






思路：
先考虑如果将军数量为偶数时，我们可以根据奇偶性把点分成两部分，这两部分的点都没有直接相连的，也就是这两部分内部的点可以使用相同颜色的勋章。那么我们只需要找出两个部分的最大值，相加即为答案。那么为什么将军数量为奇数时不行呢，因为如果是奇数个点就无法拆成上面两个集合的形式，第n个点放到哪个集合都不合适，那么关键的问题就出在了第n个点与第一个点冲突的勋章数量上。显然判断这个东西，我们需要勋章数量。

我们先二分一个勋章的数量，然后用dp判定是否可行。

所以我们考虑用dp来递推最小的和最大的冲突数量。

maxn[i]表示在不与第i-1个点冲突的前提下，与1号点冲突的最大值。

mx[i]表示在不与第i-1个点冲突的前提下，与1号点冲突的最小值。

maxn[i]=min(a[i],a[1]-mx[i-1])  因为要使i和1冲突尽可能大，而又不能与i-1冲突，所以我们令i-1与1的冲突尽可能小，除去mx[i-1]，a[1]中的点都可以选，所以上面的式子得证。

mx[i]=max(0,a[i]-(x-a[i-1]-a[1]+maxn[i-1)) 我们希望冲突尽可能的小，那么也就是除了不得不冲突的情况，其他的都不冲突，那么如果计算不得不冲突的情况呢？我们一共有x中颜色，x-a[i-1]-a[1]+maxn[i-1]表示x中除去与i-1冲突的除去与1冲突的（令i-1和1冲突最大，能保证剩下的点最多）所能选取的点，如果点数不足a[i]，那么必然要与1发生冲突。

最后判断是否可行，只需要判断mx[n]是否为0即可，因为推得时候保证与前一个不冲突。

注意二分答案的最小值不能是1，因为我们推的时候保证i不与i-1冲突，所以最小值应该是相邻两个加和的最大值。
*/
