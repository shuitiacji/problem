bitset:
1.对于给定中等范围中询问数字有没有出现，考虑bitset
2.多个元素去重，求公共个数，考虑bitset

01分数规划
分数最优，一般采用二分法，用其他模型算函数值：
∑valuei⋅xi−r∗⋅∑costi⋅xi=0
f(r)=∑valuei⋅xi−r∗⋅∑costi⋅xi
=∑(valuei−r⋅costi)⋅xi
大于0往右，小于0往左
https://blog.csdn.net/hzoi_ztx/article/details/54898323

有向图求联通块
if(vis[v]!=cur)dfs(v,cur);
这里换成了有向图，一样有向图dfs染色一下，只要注意17行，因为是有向图，需要重复染。

线性求逆元
p/i*i+p%i=0(mod p)
p/i*i=-p%i
p/i*inv[p%i]=-inv[i]
inv[i]=-p/i*inv[p%i]
inv[i]=((p-p/i)*inv[p%i])%p

分层图思想：
通常情况下须要用到分层图思想的题目都有一些干扰操作（常见的就是能够将边权降低什么的）（P.S.前提是这些操作的数目不太大）。我们对这些干扰操作的解决方法就是把原图“复制”，并且一般来说干扰操作有多少次就要复制多少。(增加维度来分类讨论)

求边数最小的最小割的边数。
1，在原图最小割不唯一的前提下，第一次求出的最小割的边数未必是最少的。在割边集的边权和相等的前提下，可能存在一个边数更少的最小割。
2，不管有多少个最小割，我们在原图跑一次最大流之后，残量网络里面满流的边一定是属于某个或多个最小割的，相应的没有满流的边一定不属于任何一个最小割。
3，这样问题就变成——在所有满流的边中破坏最少的边数来阻断0到N-1的路径，类似在最短路的边中破坏最少的边来阻断起点到终点的路径，只是多了对非最短路边（在本题中是非满流边）的处理。
4，将满流的边cap++，在跑一次最小割就可以达到上面的目的（遍历所有正向弧，若满流则更改边权为1，否则边权为无穷大）

01trie
常研究异或和最大问题。
理论就是贪心。
按找trie一样按位0,1建树。
查询时尽可能走与当前位不一样的。
可带修改，持久化（一般询问一段区间内，考虑持久化）

斜率优化
https://blog.csdn.net/lxc779760807/article/details/51366552

网络流
流常用技巧：
拆点，拆边，分层图。
割常用技巧：
胡伯涛论文

扫描线
多维问题消去一维

MITM
对于问题答案可逆时（比如说和相等之类的）
先dfs前一半答案放进map里
再dfs后一半在map中对照

标记永久化
多维线段树，不pushdown，路过那个节点把贡献加上

模拟退火

线段树合并
在一些与排序有关的题目中，常建权值线段树来合并处理

高精度除
二分答案转高精度乘

拓扑排序判环
判环的东西，我们能想到拓扑排序,我们发现一张图可以完全的拓扑排序是在该图为有向无环图的时候，那么如果有环呢？环里面的点是不会被加入排序队列里面的，也就是排出来的点数小于n
一些题目要求加边（不加点），判环
只看有向边的话,原图是个有向无环图,也就是说是个拓扑图,如果加完边后依然是拓扑图,也就是依然无环。
对原图做拓扑排序,得到每个点的入队时间,加边的时候把边定向为从入队时间早的点到晚的点,原来的入队顺序就依然成立,就无环了。

bfs相关
一些题目经常要看一个点到其它一堆点的最小距离，往往可以正难则反，以那一堆点为起点跑一次bfs

离线版本树

题意:早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能,那就是
它具备撤销功能,厉害吧。
请为这种高级打字机设计一个程序,支持如下 3 种操作:
1.T x:在文章末尾打下一个小写字母 x。(type 操作)
2.U x:撤销最后的 x 次修改操作。(Undo 操作)
(注意 Query 操作并不算修改操作)
3.Q x:询问当前文章中第 x 个字母并输出。(Query 操作)
文章一开始可以视为空串。

思路：首先这题可以算是可持久化的裸题，但对于不要求在线，我们考虑把它的每次修改操作版本建出来，对于T，把版本i与i+1连一条线，U把i与i-x-1连线，就可以愉快地在这个版本树上离线跑dfs(需要回溯，操作必须可逆） O(n)解决。
能解决这类题目的条件是:
1.允许使用离线算法,进而求出版本树,并允许把询问挂到树的节点上。
2.所有操作都是可逆的。只有所有操作都是可逆的,才能按欧拉序依次求
出各版本。如本题的 Type 操作的逆操作就是弹出栈顶,Undo 操作则根本不需
要修改(Undo 前后 2 个版本相同)。



