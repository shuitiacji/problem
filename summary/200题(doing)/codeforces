1. 398 B
题意：
有一个n*n的方格，有m个方格有颜色，现在随机涂方格，可以重复涂，求使得每行每列至少都有一个方格有颜色的期望步数．

思路：
对于这种末状态确定，初状态步数未知（甚至无限），可以采取倒推．
设d[i][j]表示还有i行j列未有颜色方格时，到末状态的期望步数．
d[i][j]=(1+i*j*d[i-1][j-1]+i*(n-j)*d[i-1][j]+(n-i)*j*d[i-1][j]+(n-i)*(n-j)*dp[i][j])/n*n
但式子中有两个d[i][j]，这里有个技巧，可以通过移项减下系数解决．
最后特殊处理i,j==0的情况

2. 605 E

题意：
有n个点，每天i号点到j号点的有向道路有pij的概率开放。每天可以走一条开放的道路或者留在原地，求从1号点走到n号点的最优期望时间。

思路：
因为是要求最优的期望时间，所以如果决策不能使时间更优的话就还不如留在原地。
设di表示i点到n点的最优期望时间，xi表示所有点d值第i大的点。
所以dxi只能转移到dxi-1,dxi-2,...
问题是xi如何求
这里显然应该从终点考虑了，冥冥之中得到这样一个顺序，我用终点去更新，get一个离终点最近（期望最小）的点，然后这个点会纳入其他和它相连没有它的优的点的考虑范围，然后拿这个点更新一下，get下一个优的点，你们想到了啥，dijsktra！没错就是这个玩意！
同样由dij的证明，我们可以显然的发现这个算法的正确性。

思考：
这种求最优情况下的期望，考虑改变一下状态的运算顺序

3. 716 E
题意:
给你一棵树,每条边有一个权值[0,9],让你找出所有点对(u,v)使得u到v路径组成的数能被m整除(像字符串一样组成)

思路:
点分治即可.
每次分治时在dfs时记录下每个节点的d1(从该节点到根组成的数),d2(从根到该节点组成的数),并且我们用hash_table来存d1的个数,并且存d2和deep(该节点到根的距离即深度,这样我们可以通过d1*(10^deep)+d2来表示一个数,然后对d2,deep计算hash_table中有多少个d1使得d1*(10^deep)+d2==0, 用扩欧求出这个解,在hash中找一下即可

4. 741 D
题意:一棵根为1 的树，每条边上有一个字符（a-v共22种）。 一条简单路径被称为Dokhtar-kosh当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的Dokhtar-kosh路径的长度。

思路:
dsu on tree 还可以处理树上路径问题
主要还是利用点分治的思想,把路径分为过当前根的和不过根的.
令s(i)表示1到i的路径的状态，状态是一个22位2进制数，每一位表示这个字符在路径上出现次数（偶数/奇数）。f(i)表示状态为i的当前可以统计的点的最大深度。并且显然如果能是回文串的话所有的字符数量为奇数个的最多只有一个。
用dsu on tree维护这个桶就可以了.
先继承重儿子的桶,再暴力扫轻儿子,每次在桶里找可以使当前为回文串的状态(一共23种)

思考：
这种奇偶可以转化成二进制,异或处理
一开始想的桶存的是到当前父亲路径上的值,不好继承,其实可以定一个总的即到根的路径上的值

5. 983 E
题意：
一棵n个节点的树，给你m个a链，询问你q个b链，回答对于每个b链，最少需要多少个a链才能覆盖它。

思路：
树上的链上问题，除了树链剖分，惯用的手段就是把一条链转化成半链，如b链(x,y)转成(x,lca),(y,lca)，这样就将一条链转成了两个序列。
考虑问题在序列上，有点像区间最小覆盖问题，我们自然想到原来解决区间最小覆盖问题思想——贪心，这里显然也可以贪心，每次走一条能走到dep最小点的a链，最后看能不能dep小于lca，并统计答案。
因为只往上走，一个一个跳有点慢，我们可以倍增，这里的一步可以变成走一条a链（当然也是满足贪心的最好的那条）。
实现的话，可以将每个a链也先变半链，对x，y在点上打上一个lca深度的标记，因为若在一个点的子树内存在一个点的标记的dep小于此点，那么此点也可以跳一次到那个点标记的位置，先dfs一遍，回溯的时候处理一下即可，这相当于处理出了每个点的anc[i][0]。再dfs一遍，处理各个anc[i][1~20]。

这个东西有没有问题？有的，因为有可能算重，最多可能有一条a链在b链的两个半链中都出现过被算过。如果存在这样的a链，必须要在答案中减一，因为可以用这条特别的链减小使用的a链数。
为判断这存不存在，我们在两条半链上不能直接跳到lca及以上，跳到只差一步就能到lca的那点A，如果在两个半链上的A的子树中分别存在一组a链的x与y，则绝对要减一。
子树问题可以用dfs序转在序列上，则问题转化成存不存在点对(x,y)使得l1<=x<=r1,l2<=y<=r2，把(x,y)想象成平面上的点，问题即求在一个二维矩形中（l1,l2,r1,r2）的特殊点数（坐标刚好是a链的xy）这就是二维数点的模型。
可以扫描线消去一维，用树状数组维护另一维，边扫边把特殊点加进BIT，询问就在x轴上两点l1-1,r1,存一个pair(l2,r2),在询问开始时记一下树状数组上(l2,r2)区间上的点数，结束时求一下树状数组(l2,r2)的值，再减去一开始的。

6. 992 E
思路：
同之前的做法，因为a[i]=sum[i-1],又sum单调，所以如果i满足条件则a[i]>sum[j](j<i)
不同的是，我们不利用sum单调性来倍增从而在sum序列上二分，我们可以直接在a序列上查找。
但a不是单调的，无法直接二分，我们怎么做呢。
考虑建一个max线段树，每次当儿子的max>=当前询问的值且询问的区间在其中就递归下去继续做，否则不递归，查找到第一个叶子就结束。为保证找到最左的，我们要优先递归左儿子。
这个操作的复杂度是log的，因为走一次到叶子节点是log的，一个区间最多划分成log个且区间走的复杂是log同区间加法的证明，O(logn+logn)
同时这个做法还有个好处，就是因为a是动态的，直接在线段树上查找刚好可以省去先前方法中每次都去查一下sum的log，虽然失去了一边倍增一边二分的好处，但省去了动态查询的时间。
这种非单调动态序列，要求支持快速查找大于or小于一个数的位置，可以考虑这种方法。

7. 997 C
题意：给你一个n×n的空白矩阵，你要往里面染色，可以染的颜色只有三种，符合条件的染色方案是至少出现一行或一列的颜色都是一样的，问合法的方案一共有几种。
思路:http://www.perfectpan.org/archives/2062

8. 998 C

题意：是一段只有0,1的字符串，变成全为1，有两种变法，一种花费x，使任意一段字符串逆转，一种花费是y，使任意一段字符串0变为1，1变0，求最小花费

思路：花费为x的只能改变0,1顺序，只有花费为y的操作能使0改1，但要经量使0连续在一块，要想得到全为1，要么先逆转使0都移到一起再变成1，要么直接让每部分0变1，观察010010可知当有n段字符串为0时（此时是n为3），只需改变n-1（2）次部分字符串就可使0都在一块，知道这个之后只需比较x，y大小即可
这种题目要发现题目中操作实际上减少了哪些量

9. 1000 F

题意：
给你n个数（值有重复），q个查询，每次询问在区间l,r之间存不存在值只出现一次的数，有多个随便输出一个。

思路：
一个区间可能有很多存在一次的数，我们真的随便输出一个吗。
适当对题目加上一些约束方便我们处理。
比如说，我们对每个区间都取最优的那个数。
最优，当然是最不可能出现多次，即前面后面与它一样的离得越远越好，两个同时满足不太好，我们先最优一个，在本题中就是这段区间中pre值（就是与这个数相等的上一个数的位置）最小，因为这样更容易满足条件，因为上个数离这个数越远就越不可能与这个数在一个询问区间中。
同时我们发现，这个最小值如果都不满足的话，就没有其他数满足了。
但这个东西有个问题，我们只关心了pre，没有关心nxt，如果a[i]==a[j]，i<j，且都在这个区间的话，若最小值是i的话，也不满足题意。
用扫描线来离线询问来维护nxt，我们可以一个一个把数放到线段树中，值就为pre，维护区间最小值，同时把它的pre从线段树中去除，碰到一个询问的右端点，就在线段树中查一下该区间的最小值。

10. 1004 E
题意：
给你一棵树，找出一条长度不超过k的链，使得其他所有点到这条链的最短距离的最大值最小。

思路：
这种什么跟树上距离最大最小有关的，往树的直径上想。
先求出树的直径，可以利用一个性质，一个点的最远点一定是直径的两端点之一，先随便找个点dfs到最远点，再从找到的这个直径的一端，再dfs一遍到最远点，即是另一个端点。
然后我们发现，题目要求的这条链一定在树的直径上，证明：至少有1个点会在直径上，接下来选1个点，相邻的直径点还是其他分支的点？那么必定是相邻的直径点，因为如果是选分支点，必定是这个分支中存在一个最深点到当前这个直径点的距离比它左边或右边的一截直径要大（因为选了这个分支点后，为保证这是条链，那么必定无法同时往直径上左扩张或右扩张，就会剩下半截直径），那么这个分支便可以构成一个更优的直径，矛盾。
所以只要在直径上选最优的k个连续的点，这个显然是个滑动窗口优先队列，最优化直径两个端点到k个连续区间的两个端点，还有以k-2个点为根节点的最大距离。

11. 1004 F

题意：
有一个长度为 n 的数组 a1∼n，有 m
次操作，操作分两类：
将ai修改成y；
给定 l和 r，询问有多少个区间 [L,R] 满足 l≤L≤R≤r 且 aL∼R 按位或和至少为 x。（即：aL or aL+1 or ⋯ or aR≥x）
其中 x是一开始给定的一个整数。

思路：
我们称一个区间是好的当且仅当这个区间中的所有数按位或和至少为 x。一个显然的结论是，若 [l,r] 是好的，那么 [l,r′](r′>r) 也是好的；若 [l,r] 不是好的，那么 [l′,r](l′>l) 也不是好的。我们可以求出每个左端点有哪些右端点使得所选区间是好的，这个可以用双指针 O(n) 处理。
考虑分治
将 [l,r] 分成 [l,mid] 和 [mid+1,r] 后只考虑计算跨过区间的贡献。结合上面的结论，我们可以只花费 O(n) 就计算出跨区间的答案。一次查询的时间复杂度为 O(nlogn)。
考虑优化它，可根据ＯＲ的性质，设 prefixi 表示 a1∼i 的按位或和（即前缀和）。发现，从 prefix1 到 prefixn 只会变化 O(loga) 次，因此不会有一个二进制位被删除。这个性质对子区间、后缀和同样成立。考虑用这个性质优化分治查询的过程。对于一次扫描，我们只需要花费 O(logn) 的时间。
但这个分治竟然有修改操作，我们可以用善于修改的线段树来处理
因为线段树是个分治结构，考虑修改到叶子节点向上pushup时，同时要合并两个儿子区间保存答案，通过记录一个区间的前缀和中第一次出现位 i 的位置，一个区间的后缀和中第一次（靠右）出现位 i 的位置。用这两个东西就能够在 O(logn) 的时间复杂度内算出跨过中点的答案数量。用这个就可以做到log合并
神奇的用线段树解决动态分治问题

思考：
注意一些东西的收敛性(|,&,gcd)
统计点对问题，分治也是一种做法

12. 1005 E

题意：
给你一个序列，和一个数m，询问这个序列中存在多少个子区间满足这个区间的中位数等于m（个数为偶的区间，中位数为中间那个靠左的

思路：
这种区间与排序有关的，可以一个东西作为关键字，把小于它的数置成一个东西，大于它的数置成一个东西。
询问有多少个子区间，可以先确定一个端点，利用题目性质再用一些数据结构的东西快速处理出满足的左端点有多少个。
考虑这题，如果对于第1个部分分，序列为排列的情况，可以考虑把小于m的置成1,大于m的置成-1,等于m的置成0，看区间的值是否为1或-1（先扫一遍分别把扫到的点当作右端点，可以开一个桶记前缀和，在桶中找到那个能使当前区间值符合的前缀和，即为左端点）,再特殊判一下。发现这样搞对等于m特别多的情况特别不好处理。
上述做法中，我们找的是中位数恰好为m的，在判断m的值到底是1还是-1上特别不好搞（因为m过多时会占去一部分为-1的值，过少时会占去一部分为1的值），如果能有办法使得能m为1搞一次，m为-1再搞一次就好了。
其实我们会发现ans = 中位数<=m的方案数 - 中位数<m的方案数，如果将两个分别算一下，刚好可以将m为1搞一次，m为-1搞一次。
只要像之前一样，不过把桶换成BIT，查之前有没有前缀和能小于现在的前缀和，因为只要区间的和大于0即可。

思考：
适当放缩条件(严格等于0变成了<与<=)，转化问题

13. 1009 E

题意：数轴上从0出发到n，值为1 - （n-1）的点中均可以休息，也可以不休息。现在给定一个数组a[ ]，a[i]表示走长度为i的距离的困难度（保证a[i+1]>a[i]），设每种情况出现的可能性均相同，求所有可能性的期望困难度之和p*2^(n-1)。

思路：
由期望的线性性质，对每个a[i]求出现次数
所有情况从0 -> 1都需要a[1]  =>  需要 2^(n-1) 次
若1 -> 2需要a[1]，则1必须休息，其余各点均无所谓  =>  需要2^(n-2)
若2 -> 3需要a[1]，则2必须休息，其余各点均无所谓  =>  需要2^(n-2)
若3 -> 4需要a[1]，则3必须休息，其余各点均无所谓  =>  需要2^(n-2)
......
若(n-1) -> n需要a[1]，则n-1必须休息，其余各点均无所谓  =>  需要2^(n-2)
=> time[1]=2^(n-1)+(n-1)*2^(n-2)
 
tips: 这么算会不会有重复情况？可以看到算1-2时考虑过全为休息的情况，算2-3时又考虑了全为休息的情况。但实际这不是重复的，因为全为休息的情况本来就会在1-2、 2-3、 ...  (n-1)-n 时都产生一个a[1]的困难度。其他情况同理。


time[2]：
若0 -> 2需要a[2]，则1必须不休息，其余各点均无所谓 => 需要2^(n-2)
若1 -> 3需要a[2]，则1必须休息，2必须不休息，其余各点均无所谓 => 需要2^(n-3)
若2 -> 4需要a[2]，则2必须休息，3必须不休息，其余各点均无所谓 => 需要2^(n-3)
若3 -> 5需要a[2]，则3必须休息，4必须不休息，其余各点均无所谓 => 需要2^(n-3)
......
若(n-2) -> n需要a[2]，则n-2必须休息，n-1必须不休息，其余各点均无所谓 => 需要2^(n-3)
=> time[2]=2^(n-2)+(n-2)*2^(n-3)

=> time[i] = 2^(n-i) + (n-i)*2^(n-i-1)   (其中1<=i<=n)


