1. 2053
题意:
同一时刻有 N 位⻋主带着他们的爱⻋来到了汽⻋维修中心。维修中心共有 M 位技术人员,不同的技术人员对不同的
⻋进行维修所用的时间是不同的。现在需要安排这 M 位技术人员所维修的⻋及顺序,使得顾客平均等待的时间最小。
说明:顾客的等待时间是指从他把⻋送至维修中心到维修完毕所用的时间。

思路:
两个不同的人修车是可以同时进行的,使得计算总时间变得复杂
这里有一个对付这种情况的套路
我们把每个修⻋师傅拆成 n 个点,对于第 a 个点, ak 代表在这个师傅这里是倒数第 k 个修⻋的,对答案的贡献为k * T,把这个作为费用即可

2. 2057
题意:
幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。
我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？

思路:
问题与意愿有关,每个人有选择主见与违背两种选择,且与他人的状态有关
容易想到以意愿建'二分图'(不能说是二分图,同一部其实也有连边),最小割来表示选不选
实现时这样建图：直接将S连向同意的人，T连向不同意的人，若两人是朋友，则在他们之间连一条双向边（这里有些人不理解：若两个人有冲突，则只需要其中任意一个人改变意见就行了，简单说是让a同意b的意见或者b同意a的意见，所以只需割掉一条边满足一种情况就可以了，但是有两种情况，所以建双向边,即有可能在二分图的同一部中有连边,若xy中,x被割即x改变意见,x->y就不会割,但y被割也有情况,所以y->x也要建）。最后就是求最小割了，直接套上最大流的模板就ok了。

3. 3182
题意：

给你一个N*N的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放N枚棋子（障碍的位置不能放棋子），要求你放N个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。

思路：
正解：组合数学+高精度。
因为每一行和每一列都只有一个障碍，所以不难发现行和列是可以交换的。
我们把障碍移动到主对角线上，发现答案就是错排公式。
看上去这就是一个递推问题，那么递推式是如何推出来呢？ 当 n 个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用 D(n) 表示，那么 D(n−1) 就表示 n−1 个编号元素放在 n−1 个编号位置，各不对应的方法数，其它类推.
第一步，把第 n 个元素放在一个位置，比如位置 k ，一共有 n−1 种方法；
第二步，放编号为 k 的元素，这时有两种情况：(1把它放到位置 n ，那么，对于剩下的 n−1 个元素，由于第 k 个元素放到了位置 n ，剩下 n−2 个元素就有 D(n−2) 种方法；(2第 k 个元素不把它放到位置 n ，这时，对于这 n−1 个元素，有 D(n−1) 种方法；
综上得到
D(n) = (n-1) *(D(n-2) + D(n-1))
特殊地， D(1) = 0, D(2) = 1

思考：
去除一些无用的约束，转化问题

4. 3232
题意：
一个无向连通图，顶点从1编号到N，边从1编号到M。 小Z在该图上进行随机游走，初始时小Z在1号顶点，每一步小Z以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z 到达N号顶点时游走结束，总分为所有获得的分数之和。 现在，请你对这M条边进行编号，使得小Z获得的总分的期望值最小。

思路：
很容易就能看出这是一道期望题
我们要知道每条边被经过的期望值，然后期望值小的给一个比较大的编号
怎么求每条边被经过的期望值？
每条边是否被经过只由它所连接的两端节点决定
由于每个点到与之相连的任意一条边的期望相等，所以到某条特定的边的期望就是经过这个点的期望值乘上 1 / 该点的总边数
那么一条边被经过的期望就应该是两端点到这条边的期望值之和
那么我们就将求边的期望转化为求点的期望
显然的,可以看出每个点的期望是由与其相连的点的经过的期望决定的
设 f[x] 为点 x 的期望, num[x] 为点 x 的总边数, f[x] = sigma(f[i] / num[i]) (i为与x相邻点的编号)
每个点都能够列出这样一个方程
直接用高斯消元法解即可
注意
点 1 与点 n 有些特殊
由于"游走"是从点 1 开始,则计算点 1 期望时实际期望应该是原期望+1
若有点和 n 相连,那么在计算期望时是不需要将其算入的,因为到了点 n 的时候是不会继续"游走"了
注意这两个点,就没有什么问题了
记得将每条边的两端存起来这样最后计算每条边的期望就很简单了

这个边转点的套路可以学习一波

5. 3899
谈笑风生
思路：
关于这种树上结构查询子树内满足特殊条件的点，可以尝试线段树合并。
先离线询问，dfs一遍时把儿子的线段树合并，线段树的值域为dep，同时查询答案，再将自己update进去

6. 3980
题意:
申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti 天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。

思路:
可以化成一个有下界的费用流.
这里有个很巧妙的解决下界问题的套路
把天数化成一条链,第i天对i + 1天连一条容量为inf - a[i]费用为0的边,s对第1天连容量为inf费用为0的边,第n + 1天对t连容量为inf费用为0的边.对于志愿者,在si与ti + 1连一条容量为inf,费用为ci的边.
这样从源点向最后一个时间点跑费用流，如果满流就说明符合条件，此时的费用就是最小的费用。 
我们注意到inf - a[i] 相当于定义了这个点的下界,流断了这条边时这就相当于少了a[i]得用带权边补全INF

思考：
同样是利用流断一条边，使得其他的流量走费用边

7. 4187

题意:有n个格子，用m种颜色覆盖，每次只能覆盖k个格子，原来有颜色也可以覆盖，每个格子都要有颜色，问一共有多少种最终状态？

思路：
首先发现性质，最终状态要求至少有一个长度为k的相同颜色的块
逆向思维，dp处理没有这样的块的方案。
dpi为在i时没有这样的块的方案，枚举最后一段相同颜色的长度转移，前缀和优化。

8. 4251
题意:
小凸和小方是好朋友，小方给了小凸一个 n × m (n≤m) 的矩阵 A ，并且要求小凸从矩阵中选出 n 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 n 个数中第 k 大的数的最小值是多少。

思路:
不能在同一行,同一列,可以把行与列抽象成点,跑二分图匹配.
但这个题问的很奇怪,可以二分个答案,若矩阵a行b列的数小于等于二分中点，则由a行向b列连边,判断能不能取出 n-k+1 个 <=mid 的匹配

9. 4755
题意：
求数对(i,j)满足max(a[i], a[i + 1], a[i + 2], ..., a[j]) <= a[i] * a[j] (i <= j) 的个数。

思路：
考虑这个东西与一段区间的最大值有关，并且这个最大值将这段区间划成了两半，显然这个最大值只对跨过它的数对有影响，如果是没跨过它的，显然在左边一段与右边一段内，这个可以递归两边下去做。
这个东西的形式与分治很像，但是它不是严格按mid来划分为两半，而是由最大值划分，不管它的复杂度，先分析一下具体实现。
假设我们在计算区间 [l,r] 数对的数量，其中这个区间的最左端的最大值的位置为 mx ，那么我们可以先考虑处理 [l,mx-1] 区间数对的数量和 [mx+1,r] 区间数对的数量。
对于当前分治区间 [l,r]，当我们确定了 ai(i在[l, mx - 1]中) 时，只需要求 [mx+1,r] 中数字不大于 mx / ai的即是以 i 为左端点答案的对数，这个可以记录询问，离线二维数点。但是一个点对是由左右端点形成的，不仅可以枚举在[l, mx - 1]中的左端点，也可以枚举[mx + 1, r]中的右端点来获得跨越mx的点对数。
于是计算答案时，我们出现了两种算答案的方法，是枚举左端点，还是右端点。
显然看[l, mx - 1]与[mx + 1, r]哪个小枚举哪个。

接下来考虑这个东西的复杂度。
对于分治区间[l, r]，由于我们对它的操作数只是枚举小一点的那个区间，而这个小区间的大小一定是比原区间大小的一半还要小。我们可以联想到启发式合并中，也是只运算了小的那一部分，并且将两者合并起来，这个只不过是启发式合并的逆形式（只运算了小的一部分，将两者分裂开来），这种“启发式分治”的复杂度显然也是log的。

注意我们不能真正按分治的形式写，因为如果不预处理出一段区间的最小值，每次按分治区间大小去算，上述分析就失效了。

思考：
数对计数，分治
按特殊点分治，一定要仔细分析复杂度

10. 4768
题意：
本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。 魔力之都可以抽象成一个 n 个节点、m 条边的无向连通图（节点的编号从 1 至 n）。我们依次用 l,a 描述一条边的长度、海拔。 作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免 的。由于整个城市的排水系统连通，因此有积水的边一定是海拔相对最低的一些边。我们用水位线来描述降雨的程度，它的意义是：所有海拔不超过水位线的边都是有积水的。
Yazid 是一名来自魔力之都的OIer，刚参加完ION2018 的他将踏上归程，回到他 温暖的家。 Yazid 的家恰好在魔力之都的1 号节点。对于接下来Q 天，每一天Yazid 都会告 诉你他的出发点v ，以及当天的水位线p。 每一天，Yazid 在出发点都拥有一辆车. 。这辆车由于一些故障不能经过有积水的边。 Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。 需要特殊说明的是，第二天车会被重置，这意味着：
车会在新的出发点被准备好。
Yazid 不能利用之前在某处停放的车。 Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他步行经过的边的总长度。请你帮助 Yazid 进行计算。 本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。

思路：
考虑离线，显然排序边的海拔与询问的海拔，一边做过去，只会加边，对于答案，显然是在同一个并查集内都可以开车到达，然后只需要查这个并查集内里离终点最近的点。这个可以在并查集合并的时候取个最小值。
考虑在线，能否把所有可能出现询问情况记下来，快速查询。
考虑把并查集持久化，（也就是用主席树维护f与ans的历史版本），对边排序，每加一条边记录一个历史版本。查询时把权值离散化，二分查到是哪个历史版本，跳回去查询即可。

思考：
一种空间换时间的方法，类似前缀和，把询问有可能出现的所有情况先预处理出来，询问时只要查询即可

11. 4774
思路：
给了一个神奇的条件lcm(pi) <= 10 ^ 12,引导我们往扩展中国剩余定理上想
考虑这个东西可以写成一个方程的形式：
ai + atk * x = pi * y
ai = atk * x (mod pi)
为了变成CRT的形式，把atk的逆元除过去
ai * atk ^ (-1) = x
但要注意，因为这里的pi不是质数，所以有可能没有逆元，但方程仍是有解的：
2 = 4 * x (mod 2)
显然4在mod 2意义下没有逆元，但该方程显然有解
在这种情况下，我们要判一下，是否gcd(atk,pi) 也为ai的因数，这样就可以除掉这个gcd，使得逆元存在，若不满足，则无解

还有一个任务，就是得到方程的系数，由于条件很特殊，用set维护一下即可。

最后是合并方程
对于：
x = y1 (mod p1) -> x = y1 + p1 * k1
x = y2 (mod p2) -> x = y2 + p2 * k2
p1 * k1 - p2 * k2 = y2 - y1
用扩欧求出一个最小整数解k1，带入可以解出一个x0的特解
因为x要最小，k1与其相邻解的间距为p2 / gcd(p1, p2), 又x = p1 * k1 + y1, 所以x与其相邻解的距离为p1 * p2 / gcd(p1, p2) == lcm(p1, p2)
所以x = x0 (mod lcm(p1, p2))
于是将两个方程合并为一个，一直做下去就可以解出来了

思考：
注意到lcm的条件

12. T22526

题意：
给你一个长为n的序列a和一个常数k
有m次询问，每次查询一个区间[l,r]内所有数最少分成多少个连续段，使得每段的和都 <= k
如果这一次查询无解，输出"Chtholly"

思路：
先考虑贪心，显然可以每次跳到最远的点，这样搞是对的。
先预处理出每个的nxt，显然可以维护两个指针，线性扫一遍处理出以每个为开头的块可以跳到的下一个块。
可以倍增一下，每个询问log级回答。
这种区间上的区间覆盖+分块问题，会被询问的l，r影响，都可以贪心找跳一次最远，预处理出倍增数组，log级回答询问

