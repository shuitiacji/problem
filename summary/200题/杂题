1. attack (yali 18.7.10)
题意：
你将向敌方发起进攻!敌方的防御阵地可以用一个N × M的 01 矩阵表示,标为 1的表示有效区域,标为 0 的是敌人的预警装置。
你将发起K轮进攻,每一轮选定一个矩形区域对其进行轰炸。如果K轮后存在一个有效区域每次都被轰炸到,并且没有一次触发敌人的预警装置,那么将对敌人造成致命打击。现在你想知道一共有多少种不同的轰炸方案能对敌人造成致命打击,输出对 998244353 取模的结果。

题意：
因为矩形个数过多，显然要从点考虑。
有一个想法是看1×1的有效区域被多少个有效的矩形覆盖，答案为cnt^k。这样的方案记为1*1
显然会算重，可以考虑容斥，因为被多个矩形同时覆盖的始终是矩形，这个区域长度+1宽度+1都会算重更多，要减去1*2,2*1,同时加上2*2

考虑一个矩形，对它区间内的点的贡献可以差分搞，对它的(x1，y1) + 1,(x2,y2 + 1) - 1,(x3 + 1,y3) - 1,(x4 + 1, y4 + 1) + 1。（分别为左上端点，左下端点，右上端点，右下端点
考虑枚举有效矩形，可以分别对以(x,y)为左上坐下右上右下端点的矩形枚举个数，搞个单调栈枚举行扫一遍列即可。

2. A (yali 18.7.6)
题意：
给定一个长度为n的序列A，下标从1开始。对其依次进行m次操作或询问，分为3种类型：
1 l r x ： 将Al～Ar中每个元素二进制AND一个数x
2 l r x ： 将Al～Ar中每个元素二进制OR一个数x
3 l r ： 求Al～Ar中的最小值

思路：
这个东西一看就像是线段树，但会发现这东西标记不好打，因为原来的ans值在upt后不一定还是最小值，例如：
1011 100   ans：100
AND 101 后
0001 100   ans：1
前后ans的位置发生了改变

这种普通标记无法解决的问题，类似吉司机线段树，尝试一下在线段树各种暴力操作，最后势能分析证明出均摊复杂度。
思考一下区间取min吉司机线段树中，思想即为能够直接修改max就直接修改，不能直接修改就递归下去修改。
这里也类似，先想一下什么情况能够不受影响的直接修改Min
先对每个线段树节点记一下区间的AND值和OR值
对于AND x操作，如果x&AND[o]==x&OR[o]，即三者共有的1必须是一样的，要不然区间中就会有部分值要不同程度地变小，就会有一些值变小的多一些，可能成为新的ans，满足这个条件显然可以直接修改Min，否则递归到儿子
对于OR x操作，如果((2^32-1)^x)&AND[o]==((2^32-1)^x)&OR[o]，即AND与OR在除去都会加上x的1之外，其他的1必须是一样的，要不然就会有值不同程度地变大，满足显然也可以直接修改

打标记时记两个tag OR/AND，注意不是区间覆盖，所以一个AND操作可能会影响到OR的tag

接下来势能分析一下复杂度：
先很天真地定义标记类，把一对OR[o]和AND[o]作为标记类，满足：
1.同一次upt操作中产生的新的标记(OR[o],AND[o])属于同一类
2.同一个标记下传产生的新标记属于同一类
3.不满足以上两个条件的任意两个标记不属于同一类
每一个标记类的权值等于所有子树中存在这一类标记的点的个数，势能函数就为线段树中所有标记类的权值总和。
接着我们便发现了问题，在暴力dfs时，因为修改不是直接置成当前的标记类的值，而是位运算一下(AND一个x,OR一个x)，dfs到这个节点时，有可能不一样的标记类还会存活下来（因为涉及到位运算，因为只是把OR，AND位运算一下，所以不能保证不一样的标记类一定会被搞掉，不像吉如一的例子中，不一样的一定会被搞掉），这样暴力dfs时势能不一定会减少，无法保证复杂度。
尝试更改标记类的定义
在位运算时，不能保证所有的位上都完全和原来的标记类不一样，但能保证至少有一位不同。
可以用位数作为标记类，这样的做法积累势能很快（一个数有很多位(log(w))，加一个新的就加log(w)个(还要算上路径上的log(n))），消耗很慢（每次暴力dfs到一个点只能保证至少消耗1）
总时间复杂度为O(nlog(n)log(w))

3. braveshit (yali 18.7.15)
题意：
月亮中学的勇石博士最近收了一个比他低一级徒弟,他的名字是勇矢博士,人如其名,他们两个都非常的勇敢,所以勇石博士喜欢做勇敢者游戏来训练自己徒弟的勇敢程度。
勇敢者游戏是这样操作的,一开始有个 n · m 的矩阵 A,每次勇石博士
选定一个子矩阵 ((x 0 , y 0 ), (x 0 + r − 1, y 0 + c − 1)),考虑每次一个矩阵加上:
v 2v 3v · · · cv
2v 4v 6v · · · 2cv
3v 6v 9v · · · 3cv
rv 2rv 3rv · · · rcv
现在勇石博士执行了 q 次操作,需要勇矢博士求出最后每个点的值对 2 ^ 32取模的结果

思路：
由于只有一次询问，考虑差分
但是它加的东西比较奇怪，但是它也是有规律的，把它二维差分后：
v v v ... v
v v v ... v
v v v ... v
v v v ... v
主要这是加的矩形的差分，相当于原矩形差分的差分。
也就是多阶差分，考虑把原矩形差分两次，对一次修改操作，打上4个简单的差分标记（区间加v），注意这是原矩形差分的差分（二阶差分），对它最后总的搞回来，得到一阶差分，再搞一次得到原矩形。
这个东西有一点不好搞，也就是在得到一阶差分后，原先简单的在两个角打上停止标记（负标记）的方法失效了，如已得到了一阶差分：
1 1 1 0
1 1 1 0
0 0 0 0

打上-标记
 1 1 1-3
 1 1 1 0
-2 0 0 0

再差分回到原矩形
 1 2 3 0
 2 4 6 3
 0 2 4 1

发现两个角虽然变成了0, 但还是把值扩散出去了。
因为这个东西已经差分过一次，加上的值不再都一样，而是递增的，所以打上的停止标记必须也是递增的（也就是停止标记也要差分一次）
比如说把一阶差分变成这样：
1 1 1 -3
1 1 1 -3
-2 -2 -2 6

回到原矩形
1 2 3 0
2 4 6 0
0 0 0 0

4. B(yali 18.7.6)
题意：
给定一个长度为n的01串和一个长度为m的01串T
S通过给定的参数a,b,c构造，其中a满足gcd(a,n) = 1
Si = [(a*i + b) mod n >= c]
现在有q个操作或询问
1 p：询问S的第p位开始往后取m位得到的字符串与T有多少位不同
2 p：将T的第p位取反

思路：
观察 S 的生成方式, 发现 (ai + b) mod n 会取遍 [0, n) 的所有整数, 形成一个排列.
考虑 T i = 1 的情况, 此时如果某个询问 p 在这一位有贡献, 也就是 S p+i ̸ = T i , 一定有
S p+i ∈ [0, c)
S p ∈ [0 − ai, c − ai)
T i = 0 的情况同理. 注意上述的区间是模意义下的, 实际上可能对应着一个或两个区间.
所以我们只需对每 T 的每一位分开预处理贡献即可. 时间复杂度 O(m log m).


5. digit (yali 18.7.14)
题意：
给一个数n,求n的最小倍数,倍数数位上要求不含有给出的m个数位

思路：
考虑贪心，从小到大枚举不存在不合法数位的数，找到第一个是n倍数的即为答案。
这个枚举也就是从低位到高位,每一位从小到大来放数。
考虑优化减枝。
因为条件是恰好整除，引导我们往余数上想。
考虑数位 dp,也就是令 dp i 为 mod k = i 时候的最小数。
我们发现每次选余数相同最小数一定是优的，可以利用这个来减枝，即若当前数字mod k的余数已经出现过了，就可以不用选了。

因为答案太大可能存不下。
考虑用bfs代替上述过程，bfs每个节点只记当前选了1-9中哪一个，找到一个合法的节点就往上跳，把途经的数字倒序输出。

6. Divide (yali 18.7.4)

题意：
共有n艘飞船参与演练，每艘飞船都有一个武力值wi
你需要把它们分成两队，每队飞船数目任意
我们发现，如果两艘飞船i与j的武力值相加不小于m且不在同一队，那么这两艘飞船就能配合默契
请问最多能有多少对飞船配合默契，同时还需要算出有多少种分队方案可以达到此效果

思路：
如果考虑dp，设f[i][j]表示前面已经搞过了i个，有j个在A队，发现这样dp有后效性。
解决后效性，考虑更改dp顺序
首先把w排序
考虑[1,n]这段区间
如果 w1+wn < m，那么w1与区间中所有飞船配合都不默契，递归处理[2,n]
如果 w1+wn >= m，那么wn与区间中所有飞船配合都默契，递归处理[1,n-1]
把每次处理的w依次取出，形成一个新数组，如：w1 w2 wn wn-1 wn-2 w3 w4 w5 w6 wn-3 ...
其实新数组中每个元素大小是多少不重要，重要的是它与后面的飞船是否配合默契（要么都配合默契，要么都不默契）
于是得到了新的布尔数组，再把数组反转一下（原先后的放前面，原先前的放后面），命名为op数组
设f[i][j]表示，考虑完了前i艘飞船，其中有j艘属于A队的最佳默契数
f[i][j]=max(f[i-1][j-1]+op[i]*(i-j), f[i-1][j]+op[i]*j)
方案数也是一样的
设g[i][j]表示默契数为f[i][j]的个数，dp时顺便搞一下即可。

7. farmer (yali 18.7.2)

题意：
小D有一棵二叉树，第i个节点权值为ai。
现在给这棵树施肥，肥料是这么工作的：
首先假设所有节点各不相同（小D这棵可能不满足），每种权值对应一种肥料，所有肥料会从根进入树中，如果一种肥料对应的权值等于当前节点的权值，这种肥料会被当前节点完全吸收，否则若肥料对应的权值小于当前节点权值，肥料会流向左子树，否则流向右子树。
查询一个点能否吸收到肥料，并且支持修改一个点的权值或者翻转一个子树（子树内所有节点左右儿子互换）
思路：
首先如果暴力，对每种肥料都要从根往下走，不同肥料走的都不一样，没有什么公共的信息可以维护，所以要换一种思路，考虑对每种肥料都普适的东西进行维护。
考虑一个节点，它对于所有肥料都有同样的限制，在它左子树中被吸收的肥料权值必须小于这个点的权值，右子树必须大于。
这样一来，询问一个点时，它到根的路径上，会有各种各样这种限制，而这些东西实际上就是个不等式，表示能流到这个节点的范围，只需要看看它的权值是否在其中即可。
维护这个东西的话，因为是不等式，只须要维护一个最大值（对于所有右子节点），最小值（左子节点）。树剖+线段树即可。
区分开左子节点与右子节点，在线段树叶子处增加一个属性值，只对属性为左的求最大，右的求最小。

考虑翻转，先在树剖中像dfs序一样来找到子树区间，并对区间内所有点的属性值取反。
这个可以打标记，同时也需要记一下对于右节点的最小值和左节点的最大值，方便swap左与右的最值信息。

8. gold (yali 18.7.23)
题意:
游戏规则如下：他们将金牌分为n堆，每堆有ai块(一开始所有a都互质)，每次一个人选择其中大于一块的一堆，并在其中拿走一块金牌，之后再算出a1-an gcd的值，每一堆只留下ai/gcd块。当下一个人没有办法拿取金牌时，则赢得这场游戏。
求先手还是后手必胜

思路:
由题意可知，只有在数列出现形如k k k ... k + 1时会有人获胜，然而另一个人肯定会让另一个人拿不到这样的序列，而k > 1时，这样的破坏总是可以做到的(随便选一个k减一即可)。所以获胜的条件即为拿到形如1 1 1 ... 2这样的序列。此时序列中有奇数个偶数。

分情况讨论:
1.初始序列有奇数个偶数
此时的状态显然对先手有利,若不考虑除gcd,两个人一轮操作分别拿一个石子,不会对奇偶数量有任何影响.而奇数除以奇数和偶数除以奇数奇偶性均不发生变化,所以后手唯一的希望是想办法除掉一个偶数的gcd来改变对先手有利的状态.
考虑若出现偶数gcd,则所有ai都必须为偶,由于一开始所有都互质,所以必定有一个奇数,所以先手可以不停地制造奇数,虽然后手也在不停地制造偶数,但场上总会有个奇数(一开始那个).
这个状态,先手必胜

2.初始序列有偶数个偶数
显然此时状态对先手不利,显然先手也要翻转这个状态,即除个偶数gcd.
此时场上有至少一个奇数,但由于先手先搞,至少一个奇数并不能保证场上一直有个奇数.
再分情况
(1 有至少两个奇数,此时虽然后手晚一点制造奇数,但仍能保证场上有奇数,后手赢
(2 只有1个奇数,但该数为1,虽然先手想制造偶数,但不能对1减1,所以后手赢
(3 只有1个奇数,该数不为1,此时终于翻转状态了,但我们不能确定之后谁赢谁输,不过直接暴力模拟之后的状态,若出现了上面讨论过的任何一种情况则得到解，否则继续递归下去
这个复杂度由于每次都是在除gcd,是log的

9. magic (yali 18.7.4)
题意:
桌面上摆放着m种魔术卡，共n张，第i种魔术卡的数量为ai，魔术卡顺次摆放，形成一个长度为n的魔术序列，在序列中，若两张相邻的魔术卡种类相同，则它们被称为一个魔术对。
两个序列本质不同，当且仅当存在一个位置，使得两个魔术序列这个位置上的魔术卡种类不同，求本质不同的恰好包含k个魔术对的魔术序列的数量。

思路：
本质不同很棘手,不妨假设任意两个魔术卡均不同
设这样算出的方案数为 ans
则真正的方案数 =ans/a[1]!/a[2]!/.../a[m]!
考虑容斥
g[i]= 至少存在 i 个“魔术对”的方案数
首先考虑如何求出 g[0]~g[n]
既然要求至少存在 sum 个“魔术对”,不妨把这 sum 个“魔术对”分配
到 m 种魔术卡里面
设第 i 种魔术卡中至少存在 s[i] 个“魔术对”,则需要满足 s[1]+s[2]+...+s
[m]=sum
选出 s[i] 个魔术卡“浪费掉”:把那 s[i] 张魔术卡顺次插入到当前所有魔
术卡后面
这样保证不重不漏
方案数 =C[a[i]][s[i]]*(a[i]-s[i])*(a[i]-s[i]+1)*...*(a[i]-1)
=C[a[i]][s[i]]*(a[i]-1)!/(a[i]-s[i]-1)!

于是可以 DP 了
f[i][j]= 前 i 种魔术卡一共钦定了 j 个“魔术对”的方案数
转移时枚举 s[i] ,用 f[i-1][j-s[i]] 更新 f[i][j]
即: f[i][j]+=f[i-1][j-s[i]]*C[a[i]][s[i]]*(a[i]-1)!/(a[i]-s[i]-1)!
其中 0<=s[i]<=a[i]-1
状态数 O(mn) ,转移总复杂度 O(n^2)
O(n^2)
g[i] 的计算:先将没有浪费的魔术卡进行排列,表示它们的相对位置,再
插入所有浪费的魔术卡
g[i]=f[m][i]*(n-i)!

设 G[i]= 恰好存在 i 个“魔术对”的方案数
假设已经求出 g[k] , G[k+1]~G[n] ,考虑计算 G[k]
G[k]=g[k]-C[k+1][k]*G[k+1]-C[k+2][k]*G[k+2]-...-C[n][k]*G[n]
特殊地, G[n]=g[n]
O(n^2) 递推出 G[k] 即可
O(n^2)


10. magic (yali 18.7.14)
题意:
达拉然国中有一条长为 n 的街道,其中也住满了 q 个法师,并且街道中每一户仅存在一种法力水晶 a i 。法师们会一种神奇的法术,就是瞬间收
集一个法力水晶,其需要消耗的法力值就是该法师到法力水晶中的距离。每个法师都喜欢一些法力水晶,并且喜欢的种类都恰好是一个连续的区间 [l, r] 。他想收集到街道中每一种他喜欢并且 存在 的法力水晶(每一种只需收集一个)。而法师很懒,呆在他所在的位置 p 不会走动,他想知道最少需要耗费多少法力值才能满足要求。

思路：
考虑离线法师到数轴上，并考虑从水晶入手。
发现一个a水晶x能造成的影响，一定是在它和下一个a水晶y之间的法师（或上一个a水晶），并且中间划开，左半边的选x，右半边选y。
因为距离是abs，要分情况讨论，在法师前的贡献算负的，在后的算正的，这个显然可以用线段树维护。
同时还要看这个法师前面选了多少个水晶，后面选了多少个水晶，因为要加上或减去这个法师的位置，这可以再开个线段树维护。

当法师对水晶有要求时，这变成了一个二维问题，不止和位置有关，还要考虑种类。
用扫描线消去一维，对水晶种类排序，按种类加进去，在每个法师询问开始与结束用差分打标记即可。

11. magic (yali 18.7.16)
题意：
给你一个自然数列，把其中一些数的状态设为1,其他为零，有一种操作可以选择一段连续的长度为奇质数的数列反转状态，求最少几次操作可以把所有数变为0

思路：
这种01串反转一段区间，差分后，对所有的1两两匹配消除。
考虑任意两个数 i, j 之间需要的操作数.
1当 |i − j| 为奇质数时, 需要一次操作.
2当 |i − j| 为偶数时, 需要两次操作. (哥德巴赫猜想)
3当 |i − j| 为奇非质数时, 需要三次操作. (分解为偶数减奇质数之差)

贪心的尽量选1,实在不行选2,再不行就3。
考虑实现，因为这个与奇偶相关，又是匹配，容易想到把所有差分中的1按位置的奇偶分成二分图，并且n^2暴力建满足1情况的边，先跑一遍二分图匹配。
接下来是2情况，除去已经匹配的，分别在两个部分，同一个部分内两两匹配
最后有可能两边都剩下了一个，再按3情况匹配。

12. multiset (yali 18.7.16)

题意：
你的魔法导师有 n 个魔法抽屉, 编号为 1, 2, 3, ..., n, 并且这些魔法抽屉和它们的主人一样法力无边.
这些抽屉原本都是给魔法导师存放贵重物品的, 但由于这几天魔法导师外出旅行, 带走了所有的物品, 所以现在所有抽屉都是空的.
对于所有的魔法抽屉都有一个相同的收纳机制, 若该抽屉要收纳一个没有在该抽屉中出现过的物品, 则将这个物品简单的收纳进去; 而当该抽屉要收纳一个已经在该抽屉中出现过的物品, 则该抽屉中的每个物品会被复制成双.
例如, 该抽屉中原本有 1 个 1号物品, 2 个 2号物品, 1 个 3号物品. 若再将一个 2号物品放入该抽屉中, 则现该抽屉中有 2 个 1号物品, 4 个 2号物品, 2 个 3号物品. 而若将一个 4号物品放入该抽屉中, 则该抽屉中会有 1, 3, 4号物品各 1个, 2号物品 2个.
这显然不符合质量守恒定律和能量守恒定律, 然而在魔法学院却司空见惯.
你的魔法导师发现有人在动他的魔法抽屉, 于是给你隔空传来了一道难题, 他给了你 q 个操作,
分为两类.
第一类操作表示你需要对于第 l, l + 1, l + 2, ..., r 个抽屉施展魔法,放入 x 号物品.
第二类操作表示你需要输出第 l, l + 1, l + 2, ..., r 个抽屉的物品个数总和, 这个和可能很大, 所
以请你输出答案对 998244353 取模的结果.

思路：
势能分析线段树，能直接打tag就打，不能就暴力递归下去。
对每个节点记一个appear，一个full，这两个hash数组分别表示这个节点中出没出现过一个抽屉有这个物品，和这个节点的抽屉是不是全有这个个物品。
显然如果full中满足，则可直接打*2标记，若appear没有这个物品，则打+1标记，若full不满足而appear满足，就暴力递归。
会被卡空间，可以使用gp_hash_table，以及玄学调参线段树，空间开2.8倍。

13. olddoc (yali 18.7.15)
题意：
世界线变动率 0.14934034
本来预定月亮中学的老中医 (lzy,并非出题人) 同学在中考时不小心考
挂了,拿了 5A1B,这样他就进入不了月亮中学了。他非常的伤心,思来想
去觉得他必须拯救自己,于是找到了他曾经发明的 D-mail,决定改变这个
悲惨的世界线,于是他需要发送数学压轴题的答案给但是考场上的自己,所
以他决定构造一台 Time Leap Machine
他现在有一台 Time Leap Machine 的原型,也就是一个 n 个点 m 条
边的无向图,他需要为每条边定向,同时为了精确跳转到考场上,他需要满
足一些限制,即定向后的图需要满足可以从 x 沿着有向边走到 y,现在为了
精确构造 Time Leap Machine,你必须确定每条边为了满足所有限制是只能
定某一个方向还是对任意方向都有合法方案存在
一行 m 个字符,其中第 i 个字符是:
如果只有 u i → v i 存在合法方案时,输出’R’
如果只有 u i ← v i 存在合法方案时,输出’L’
如果这条边不论如何定向都存在合法方案时,输出’B’


思路：
考虑对原图的边双缩点，发现只要是在边双内的边，由于都有两条路径，绝对是B。则问题转化成，给你一个树，选定几个路径，把树边染色。
树剖即可。


14. operation (yali 18.7.2)
题意：
有一个长度为n的01序列，m次询问，每次询问给出一个区间，你可以进行若干次操作，每次选择这个区间的一个长度为k的子区间，并将这个子区间内所有01取反，求至少需要几次操作才能将这个区间内的所有元素变为0。
每次询问都是独立的，你在一个询问中进行的操作不会影响到另一个询问。

思路：
区间取反，想到差分，即解决将一段区间内的差分1通过每次移动k，与其它1相消的最小步数。
因为只能移动k，只要看这段区间模k意义下数字相同的个数是否为偶数，就知道是否有解，有解再贪心取离自己最近的模k相等的数。
可以莫队，但是有更优秀的做法。
可以先记一个前缀和，表示移动步数，如果暴力去减出一段区间的答案，若这段区间本身都是偶数就没有关系，有奇数输-1即可
问题转化成快速判断一个区间内是否存在奇数个模k意义下相同的数。
考虑只要求奇偶，什么东西偶数次操作为0,奇数次操作非0 —— 异或
我们可以对异或也记一个前缀和，这样可以快速得到一段区间内所有数模k后的异或和。
但这样会有问题，比如说 1010 可以被1000与10搞掉，而不是他自己。
因为k较小，单纯用模k后的值搞，范围小，容易像上面这样搞掉。
可以对每种数随机出一个较大的值来防止这种冲突
最后特殊考虑区间左端点右端点的情况。


15. practice (yali 18.7.22)
题意:Rudy Brave Gay 是一名刻苦训练的运动员,为了夺得总冠军,Rudy Brave Gay 开始了
夏季集训。科尔给 Rudy Brave Gay 准备了一棵以 1 为根的树,这棵树上有黑色、白色两种节
点。科尔每次会给 Rudy Brave Gay 划分一个子树出来让他在上面练习运球。由于 Rudy Brave
Gay 太 Brave 了,他只愿意以黑色节点为起点和终点运球,于是他想知道划分区域内满足条
件的路径最长是多少。一开始全部都是黑点,为了考验 Rudy Brave Gay,科尔还会修改点的
颜色。

思路:
有一种很套路的线段树维护树的直径的方法
先把树上节点dfs序映射到线段树上
此时线段树上的节点维护的是自己这段区间内的点,所组成的直径的两个端点.
考虑两个区间合并时,假设我们已知两个子节点的直径和直径的两个端点,那么父节点的直径的两个端点一定是这四个端点的其中两个
由于是按dfs序来的,可以很方便的处理出子树内的直径
由于是线段树,还可以支持修改


16. rockginger (yali 18.7.15)
题意：
求一个n点任意图（可以不联通）为欧拉图的概率

思路：
先研究一些性质
考虑欧拉图的充分必要条件是连通与所有点度数为偶数,那么先考虑设 s(n) 表示 n 个点的所有点度数为偶数的图的个数
考虑一个有偶数个奇度数点的图,新加入的点只要和所有奇点连边就可以使得这个图满足条件,那么 n 个点的偶度数图和 n − 1 个点的所有图
都是一一对应的,那么 s(n) = 2 ^ (C(n - 1, 2)) (因为一条边会对总度数+2,如果有奇数个奇数度点，总度数就不会是2的倍数，所以是一一对应的，而n-1点的图的总数是先找到所有的边C(n, 2), 再2的幂次判这边存不存在。)

满足了度数，同时还要判联通性。
考虑容斥解决这个问题
考虑设 f (n) 表示 n 个点的欧拉图个数,那么考虑一个枚举一号点所在连通块点数的简单容斥:
f(n) = s(n) - sigma(C(n - 1, i - 1) * f(i) * s(n - i)) (i < n)

最后除个总个数，即为概率

17. tree(yali 18.7.1)
题意：
有一棵n个点的有根树，点编号为1-n，其中1号点为根，除了1号点外，i号点的父亲在1～i-1内均匀随机。
定义一棵树的深度为所有节点到根路径上节点数的最大值，求这棵树的期望深度。

思路：
首先要明确，因为是求节点数的最大值，而期望的线性性质只在加法上有效，这题就无法用期望来做，只能转化成记数问题，最后乘个逆元。
考虑还要看节点深度，我们的状态必须要记前面节点的深度，而这样不好处理。
我们研究一下题目性质，这里会有一个十分套路的状压：
我们要最好将这些个点的深度变成二进制，同时会发现，深度一定是连续的（每次加一个点，深度最多增加1），也就是说如果将前面点深度从小到大排序，每个点之间都会只差1或0,如果把这个东西差分一下，就完美把深度序列变成了二进制的01串。
转移的话，每次加点进来，枚举这个点的深度，直接在状态中找到那个深度，往后加个0即可，当然也有可能是新的深度，往最后加个1：
如11001转移：
深度为2：1100+0+1 ——> 110001
深度为4（新的深度） 11001+1 ——> 110011
这个实现的话很简单，加1的直接加，加0的话，把它这个深度后面的全减掉，左移，再加上刚减掉的。
同时一个深度i点只有可能通过深度i-1的父亲转移，只要找深度i-1的有多少个，就可以很方便的计数。

这种非01序列，如果差只为01,可以差分转成二进制状压。

18. tree
题意：
给定一棵 n 个点的树,每条边有个正整数边权。有 q 次修改操作,每次会修
改一条边的边权。
在所有修改前以及每次修改后,你需要求出有多少个无序点对满足它们之间
的最短路径上所有边权的最大公约数=1。

思路：
考虑莫比乌斯反演，按之前在序列上的套路：
设F[n]表示gcd为n的倍数的点对，f[n]为gcd为n的点对
f[n] = sigma(F[i] * mu[i / n]) (n | i)
ans = f[1]
但不同于序列上的是，这里的F[n]并不是很好求
考虑若一条路径上的所有边若都是d的倍数，则肯定可以为F[d]作出贡献
则枚举d(mu[d] != 0)，把是d倍数的边加到并查集中，并计算答案。

对于修改操作，由于修改较小，可以对于修改涉及的边,我们一开始不将它们加入并查集。然后我们枚举 q+1 个时刻,再将这些边加入,统计答案,再删去即可。



