1.ball hzw14.6.28

«问题描述：
假设有n根柱子，现要按下述规则在这n根柱子中依次放入编号为1，2，3，...的球。
（1）每次只能在某根柱子的最上面放球。
（2）在同一根柱子中，任何2个相邻球的编号之和为完全平方数。
试设计一个算法，计算出在n根柱子上最多能放多少个球。例如，在4 根柱子上最多可放11 个球。
«编程任务：
对于给定的n，计算在n根柱子上最多能放多少个球。


思路：
直接求解较为困难，考虑转化为判定性问题，即在n根柱子上能不能放a个球。 
我们把球一个一个放进来
观察本题，对于一个进来的编号的球，他有两种情况，
1.放在某个和他组成平方数的球的后面
2.独立门户
考虑贪心，发现不行，因为即使现在这个点可以套在其他点上，它独立门户可能价值更大(其实贪心
是可以的，但这样就练不了网络流了呀)
所以发现加进来一个点，并不能通过之前的最优状态直接转移，它需要调整。我们可以联想到网络流求最大流过程，每个流也要动态调整，于是去往网络流上想。
对于图论建模，有很常用的办法，那就是针对不同状态拆成不同的点。
根据上述两种状态，把一个点拆成两点，一个点表示1状态，把它与其他构成平方数的点(这个点是原点的第二拆点)连一条容量为1的边，一个表示2，把它与t连一条容量为1的边。
这样求出的最大流，表示了没有自立门户的点的数量，用总量减一下，即得到自立门户的，也就是柱的数量。


2.mex hzw14.5.17
题意：给你一列数，询问区间l，r，求非负整数中不在l，r数的集合中的最小值。
思路：
首先要想到离线询问
1.傻逼莫队，add与remove暴力操作（无法O（1）），玄学复杂度（取决于数据卡不卡）
2.正解
先考虑暴力，若1个端点不变，for一遍右端点可以O(n)出解，如可以预处理出所有(1,1),(1,2),...,(1,n)的答案，这样枚举两个端点可以n^2暴力
现在考虑左端点不暴力枚举(也可以说是算左端点左边的最小值)(先预处理出(1,1),(1,2),...,(1,n),相当于预处理右端点，因为(1,i)肯定包含了i右边的最小值，只差左边的了)
如何不暴力枚举左端点？若把询问区间按左端点排序，如果能快速从上个区间转移到这个区间,就能够做到。
考虑从(i,j)转移到(i+1,j)，因为a[i]空出来了，对于右端点在(i+1,next[i]-1)中的询问，它的答案可以取a[i]（只是可以，若有更小的就不取）(其中next[i]表示在点i之后第一个与a[i]相同的点的位置，这个也是可以预处理出的)
这个转移操作即相当区间取min，然后对于询问的r单点查询。
线段树即可，加上每次+1的转移左端点，nlogn

思考：
多种约束的题，我们往往设法满足一个（像这题两个约束分别是左端点与右端点，通过预处理先满足右端点）
通过离线算法发现前后信息的可利用性，来进行高效转移，而不是一个个跳


3.tree hzw14.8.5
题意：
现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有n个叶子节点，满足这些权值为1..n的一个排列)。可以任意交换每个非叶子节点的左右孩子。

要求进行一系列交换，使得最终所有叶子节点的权值按照中序遍历写出来，逆序对个数最少。

思路：
子树内的交换不会对子树外的造成影响。
先考虑暴力，递归下去，枚举此时左子树的点与右子树的点，每次比较暴力算一下。
考虑优化这个比较的过程，对左子树与右子树分别建一颗权值线段树，线段树递归下去算即可。
只需要合并线段树即可，可以在算答案的时候顺便合并一下。

思考：
与排序有关的问题考虑一下权值线段树合并

4.field hzw14.6.21
题意：给你一些点，并且对于A(a1,a2),B(b1,b2),C(c1,c2),若存在a1==b1,b2==c2,则添加一点D(c1,a2)。求从原点开始的一条路径，使得经过的点所占的行数与列数的最小值尽可能大，输出这个最大值，且这个路径不能是u型的即每次y+1或x+1或x+1&&y+1。

思路：不考虑加点的话，求最大值直接按题意搞即可。
考虑如何快速加点
只考虑那个B点，它的y坐标上要有其他点，x坐标上也要有其他点，并且两两要配对去生成点，但这样很慢。
正解是把所有的列和行抽象成一个个数，用并查集维护行与列的连通性。对于点(a,b),把a列与b行在并查集中连一下，那么如果a1列b1行在并查集中联通，则(a1,b1)存在。不难发现这样搞，直接就自动把点加上去了。

5.formation hzw14.10.4

题意：
N 个编号为 1-n 的球,每个球都有唯一的编号。这些球被排成两种序列,分别为 A 、 B
序列,现在需要重新寻找一个球的序列 l ,对于这个子序列 l 中任意的两个球,要求
j,k(j<k) ,都要求满足 lj 在 A 中位置比 lk 在 A 中位置靠前,却 lj 在 B 中位置比 lk 在
B 中位置靠前,请你计算这个子序列 l 的最大长度。

思路：
将a[i]在b数组中的位置记为c[i]
求c的最长上升子序列

6.经营与开发

题意：你驾驶着一台带有钻头（初始能力值w）的飞船，按既定路线依次飞过n个星球。
星球笼统的分为2类：资源型和维修型。（p为钻头当前能力值）
1.资源型：含矿物质量a[i]，若选择开采，则得到a[i]*p的金钱，之后钻头损耗k%，即p=p*(1-0.01k)
2.维修型：维护费用b[i]，若选择维修，则支付b[i]*p的金钱，之后钻头修复c%，即p=p*(1+0.01c)
注：维修后钻头的能力值可以超过初始值（你可以认为是翻修+升级）
金钱可以透支。
请作为舰长的你仔细抉择以最大化收入。

思路：
1.容易想到dp,F[i][x][y]表示到达第 i 个星球,且之前开采过 x 次,维修过 y 次。
因为本题开 采 和 维 修对 钻头 的 影响 都是定 值 。所以 钻头 能 力 就是
w*k^x*c^y
时空复杂度:O(n^3)
2.现在分析一下这题的特殊性，dp算法的瓶颈即为存储x，y来算出钻头能力，这是理所应当的，因为能力具有后效性，在dp中必须存储。考虑研究一下这个后效性的机制，想办法把这个状态舍去。发现这个能力的影响对后面状态的影响并不复杂，是一次（没有复杂的多次操作）的，只乘上了一个数值而(就好像初始钻头能力为 w,实际上你可以按 1 来做,最后再把 ans 乘上 w)。而已。
正难则反,F[i]表示第 i--n 个星球的最优收入,且假设从第 i 个星球开始时
钻头能力为 1。换句话说,这样的状态设计,规定了一个参考系。
转移过程就变得简单:如果在第 i 个星球开采,那么第 i+1--n 个星球的初
始钻头能力就是 1*(1-0.01k)。换句话说,就是 F[i+1]*(1-0.01k)。
所以 F[i]=max{F[i+1],F[i+1]*(1-0.01k)+a[i]}
对于维护型星球,大同小异。就系数和代价的正负而已。
观察方程,F[i]=max{F[i+1],F[i+1]*(1-0.01k)+a[i]}
实际上就是取下 i+1--n 的最值而已,所以这题实际上就成了贪心。
dp时可以多分析一下某些条件的后效性，想到省掉维度的办法。

7.不等数列

题意：
将1到n任意排列，然后在排列的每两个数之间根据他们的大小关系插入“>”和“<”。问在所有排列中，有多少个排列恰好有k个“<”。答案对2015(luogu)(2012:hzwer)取模。
思路：这个题决策顺序的选择不应是按时间序，这样决策对算法优化没有任何帮助；这个时候我们应该在不影响求答案的情况下，改变决策顺序，可以按1-n依次插入的顺序dp。这样不影响结果，且把dp中不好存储的状态约束直接放在了外层循环上。
在可以设状态，把另一个约束条件<的数量放进状态。f[i][j]表示前i个j个<的方案数
容易发现当当前这个数插入之前的序列中，若是<关系的两数间，由于当前数最大，使<不变，>数目++
同上，若>关系，>不变，<++
f[i][j]=(f[i-1][j-1]*(i-j)+f[i-1][j]*(j+1))%mod

这题给了一个很好的思路，当递推顺序对dp没有什么约束时，我们可以换一种有约束的顺序方便处理出dp中状态不好存储与约束的。

8.皇帝的烦恼

题意:
经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置n名将军。不幸的是这n名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。

秦皇已经准备好了秘密处决这些无礼的边防大将。

不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第i个将军要求得到ai枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为i的将军和编号为i+1的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号1和编号n的将军也相邻）。

皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？

思路：
先考虑如果将军数量为偶数时，我们可以根据奇偶性把点分成两部分，这两部分的点都没有直接相连的，也就是这两部分内部的点可以使用相同颜色的勋章。那么我们只需要找出两个部分的最大值，相加即为答案。那么为什么将军数量为奇数时不行呢，因为如果是奇数个点就无法拆成上面两个集合的形式，第n个点放到哪个集合都不合适，那么关键的问题就出在了第n个点与第一个点冲突的勋章数量上。显然判断这个东西，我们需要勋章数量。

我们先二分一个勋章的数量，然后用dp判定是否可行。

所以我们考虑用dp来递推最小的和最大的冲突数量。

maxn[i]表示在不与第i-1个点冲突的前提下，与1号点冲突的最大值。

mx[i]表示在不与第i-1个点冲突的前提下，与1号点冲突的最小值。

maxn[i]=min(a[i],a[1]-mx[i-1])  因为要使i和1冲突尽可能大，而又不能与i-1冲突，所以我们令i-1与1的冲突尽可能小，除去mx[i-1]，a[1]中的点都可以选，所以上面的式子得证。

mx[i]=max(0,a[i]-(x-a[i-1]-a[1]+maxn[i-1)) 我们希望冲突尽可能的小，那么也就是除了不得不冲突的情况，其他的都不冲突，那么如果计算不得不冲突的情况呢？我们一共有x中颜色，x-a[i-1]-a[1]+maxn[i-1]表示x中除去与i-1冲突的除去与1冲突的（令i-1和1冲突最大，能保证剩下的点最多）所能选取的点，如果点数不足a[i]，那么必然要与1发生冲突。

最后判断是否可行，只需要判断mx[n]是否为0即可，因为推得时候保证与前一个不冲突。

注意二分答案的最小值不能是1，因为我们推的时候保证i不与i-1冲突，所以最小值应该是相邻两个加和的最大值。


9.mouse hzw14.8.2

题意:伟大的 2320 学长特别喜欢打地鼠游戏,这个游戏开始后,会在地板上冒出一些地鼠
来,你可以用榔头去敲击这些地鼠,每个地鼠被敲击后,将会增加相应的游戏分值。可是
所有地鼠只会在地上出现一段时间(而且消失后再也不会出现),每个地鼠都在 0 时刻冒
出,但停留的时间可能是不同的,而且每个地鼠被敲击后增加的游戏分值也可能是不同。最近 2320 学长经常玩这个游戏,以至于敲击每个地鼠只要 1 秒。他在想如何敲击能使
总分最大。

思路：
贪心，维护两个维度的最优，一是个数最优，可以把时间排序一个一个取，二是权值最优，不断用大的替换小的
按照时间排序，不断取，直到取得个数超过当前时间，把价值最小的删除
用堆维护

思考：
一样是多约束问题，不过换成了最优性


10.password hzw14.5.31

题意:hzwer 有一把密码锁,由 N 个开关组成。一开始的时候,所有开关都是关上的。当且仅
当开关 x1,x2,x3,...xk 为开,其他开关为关时,密码锁才会打开。
他可以进行 M 种的操作,每种操作有一个 size[i],表示,假如他选择了第 i 种的操作
的话,他可以任意选择连续的 size[i]个格子,把它们全部取反。(注意,由于黄金大神非常
的神,所以操作次数可以无限>_<)
你的任务很简单,求出最少需要多少步才能打开密码锁,或者如果无解的话,请输出-1。
思路：
注意到题目中的是区间修改，把沿途的位置取反，这个可以看做是在模2意义下，给区间的加一操作。在我们通常的思路中，对于区间的操作，原本是要修改区间长度个的位置的情况，我们都可以通过考虑它的差分序列，使得要修改的位置个数变成2个，我们要求最少的修改，使得原序列变成全0。

所以对原序列进行差分，那么每次修改就是要你对i号位置和i+size[]模2意义下的加1。

差分后的序列中，数值为1的个数是不会超过2k个，即不会超过20个。

考虑每次对i和i+x改动的过程，如果原序列中，i号位置和i+x号位置都是0的话，我们这么改，没有任何必要。所以任意时刻，数值为1的位置个数是不会增加的，那么我们可以把每一个的1看成一个的石子，那么每次我们可以把石子往某个方向移动size[]步，如果移动之后的位置存在石子的话，就对对碰，消掉了。

因为是对对碰，石子之间的关系肯定是一个匹配的关系，我们不妨求出Dist[i][j]表示，石子i要走到石子j的位置，至少需要移动多少步，那么我们可以枚举每一个石子，然后进行一遍的bfs即可，这一部分的复杂度是O(2kmn)。

现在问题转化为有一个大小不超过20的完全图，我们想要求它的最小权最大匹配。


100%的做法因为完全图的个数非常小，直接状压DP即可。对于一个状态，我们考虑其下标最小的那个位置和谁匹配了，就能递归成子问题了，复杂度是O(2kmn+2k*2^(2k))。

思考：
区间取反，考虑差分

11.table hzw14.9.6

题意：

今天CZY又找到了三个妹子，有着收藏爱好的他想要找三个地方将妹子们藏起来，将一片空地抽象成一个R行C列的表格，CZY要选出3个单元格。但要满足如下的两个条件：

（1）任意两个单元格都不在同一行。

（2）任意两个单元格都不在同一列。

选取格子存在一个花费，而这个花费是三个格子两两之间曼哈顿距离的和（如(x1,y1)和(x,y2)的曼哈顿距离为|x1-x2|+|y1-y2|）。狗狗想知道的是，花费在minT到maxT之间的方案数有多少。

答案模1000000007。所谓的两种不同方案是指：只要它选中的单元格有一个不同，就认为是不同的方案。

思路：
首先对于三个点来说他们的坐标如果交换，对花费没有影响。
所以题意=枚举3个横坐标和三个纵坐标，算合理的方案数。
不妨令x1<x2<x3,y1<y2<y3,所以花费为2(x3-x1)+2(y3-y1)，且方案数乘6即为答案（3个数排列组合一下）
所以可以只枚举2个点。
还可以优化，发现花费公式就是x1,y1;x3,y3构成的矩形周长，没有必要在意点，枚举矩形边长，根据边长推一下有多少这种矩形，同时由于x2,y2可以是矩形中的任意一点，还要乘一下x2,y2的个数。最后乘以6。


12.tree hzw14.6.21
题意：
小奇的花园有n个温室，标号为1到n，温室以及以及温室间的双向道路形成一棵树。

每个温室都种植着一种花，随着季节的变换，温室里的花的种类也在不断发生着变化。

小奇想知道从温室x走到温室y的路径中(包括两个端点),第t种花出现的次数。

• C x t 表示在温室x中的花的种类变为t。

• Q x y t 表示询问温室x走到温室y的路径中(包括两个端点),第t种花出现

的次数。

思路：
给每种花开一个线段树，考虑到种类范围有2^31，但由于n与m没这么大，可以用map映射一下。
接下来两种思路。
1.然后暴力树剖。nlognlogn
2.不用树剖也可以，运用部分和思想把单点修改，路径查询转化成子树修改，单点询问。
具体地说我们用Vi 表示点i 的权值，Si 表示点i 到根节点上的权值和，那么询问x 到y 路径的权值和时，我们找到x 和y 的lca 那么答案就是Sx + Sy – 2Slca + Vlca. 而如果修改点x 的权值，就相当于x 子树上所有点的Si 都加上了一个数，我们只要先处理DFS序列之后就转化成区间加，这样可用线段树或者树状数组实现。(nlogn,然而并没有写).

思考：
树形转线形，数据结构维护
两种不同的转化方式（树->线）成就不同的效率（树剖，dfs序）与不同的适用范围



