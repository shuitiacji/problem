1.957D

题意：你用n天时间去观察一条河，这条河的水位每天都有可能改变，所有你每天都会在当前水位上画一条线来标注（这个线永远都不会消失），当然啦，如果这个水位刚好和之前某天水位一致，也就是已经有线和水面平齐，那么当然就不需要再标记了。现在告诉你每天可以看到的水位线数量a[i]，求出∑d[i]的最小值，其中d[i]表示第i天水底下的标记线的个数
思路：设第i天总水位线的数目为m[i],m[i]=d[i]+a[i]+1;
则m[i]单调不减，且m[i+1]-m[i]最大为1
可以把问题转化成给你一堆数a[i]，可以将其任意一个+1，使得最后单调不减，且相差不超过1，求最少加几次可以
实现很简单，同时满足两个条件很困难，可以先正序一遍贪心将其变为单调不减，在倒序一遍将其变为相差只1


思考：问题转化（把条件与问题联合起来），多约束时，逐个满足。

2.980E
题意：给定一颗有 n个点的树，i号点的权值是2^i要求删去 k个点，使得剩下的点仍然连通，并且总权值和最大，问删去的所有点的编号。
思路：考虑一个特殊性质，只要选了n号点，1——(n-1)号点总和都不会超过n，于是可以不计后果的取当前最大点来贪心。可以将n号作为树的根，现只要判断一个点能不能在k且联通的限制内保留，明显只要看这个点向上走到根遍历的点数有没有超过k，于是可以倍增向上跳加速算法。

思考：研究特殊性质，树形结构向上走可以考虑倍增


3.981D
题意：
给你一列n个数，要求划分成k段，求出每段和，使得段与段之间和的&最大


思路：
这题按套路顺序dp显然有后效性，我们发现这个后效性难以消除。
我们尝试增加维度与改变dp顺序发现也解决不了。
想想后效性产生的原因，是因为当前最大不一定是答案的组成（如对于答案11010,1100也许不如1010优），而要判断这个，比须知道答案。
所以消除后效性不止要考虑维度与dp顺序，从枚举答案入手也可。（也许这种算法不能只叫做dp了，只是后面按位枚举二分答案的check部分）
因为是二进制运算，按位枚举是个不错的主意，从高位开始判断当前位是否可以为1，不难发现因为是从高位开始，若当前位为1，不存在当前为0更优的情况。这样没有枚举所有可能的答案，而且正确性显然。这样的算法就像贪心一样希望尽可能大的答案，并同时用dp判断这个答案是否可行。（有点像一种在按位枚举上特殊的”二分“答案（这样按位搞也相当于log的））


思考：
消除后效性可以考虑从枚举答案入手。对于一些与二进制有关的题目，可以尝试按位枚举二分答案。

4.981E

题意：给你n个0，给你一些区间加法操作，你可以从中任选一些操作，得到一个区间最大值，现求这样能得到哪些在1-n范围内的可能的最大值。

思路：
首先发现对于一个1-n内的值，只要存在一些操作能凑出它，它就可以为答案的一个，不需要考虑什么最大值，因为操作任选，完全可以只选凑出它的操作。
再发现这个只求1-n范围内，明显的引导我们去用bitset。
可以打个线段树维护一下区间加法，用一个bitset:b[o][i]==1表示在o号线段树节点i值能否凑出。

思考：
对于给定中等范围中询问数字有没有出现，考虑bitset

5.984C

题意：p/q   在b进制是否是一个  有限小数。
分析：只有当分母的质因数全是进制的约数时不无限。
暴力处理每次除一个gcd(p,b)有可能超时，可以将b置成每次的gcd，因为如果gcd已经在变小，即有些b中的约数在p中已经不存在，在b中留这些约数也就没有用

思考：
判断一个数的质因数集合是否完全被包含在另一个数中，可以采用这种办法。

6.985D
题意：给定n，H，要求使a数列满足a[1]+a[2]+...+a[x]=n,且a[1]<=H,a[x]=1，|a[i]-a[i+1]|<=1(1<=i<x),求a的项数最小是几。
思路：正向思考得逐步分解n，有点困难，考虑反向思考，先构造出一个长度为x的序列再去判断它的长度是否为n。
但这样也很难，可以先考虑这x长度能达到的最大和，显然H做为a[1]和更大
根据H与x奇偶性有如下两种和最大构造方式：
1.H<H+1<H+2<...<k-1<k>k-1>...>1
2.H<H+1<H+2<...<k-1<k=k>k-1>...>1
我们发现只要n<=最大和，我们都能在这个x长度中构造出（通过调a[1]，与每一项是+1，+0，-1）
如n=最大和-1
可以（假设是第一种构造）：
H<H+1<H+2<...<k-1=k-1=k-1>...>1
n=最大和-2：
H<H+1<H+2<...<k-1>k-2<k-1>...>1
n=最大和-3：
H<H+1<H+2<...<k-2<k-2<k-1=k-1>...>1
n=最大和-M(M>H):
可以调a[1]<H
于是演算过程与答案奇偶性有关，且x越大条件越容易满足，容易想到二分答案。
debug：这个问题中存在着longlong相乘溢出的情况，可以按a[1]=1,a[x]=1,在前一半a每次加1后一半每次减1，这样的和为(x/2)^2=n,可以预处理出二分的一个上界x=2*sqrt(n)。注意29,5,变量定义也要LL

思考：
注意乘法溢出，可以考虑调上下界

7.985E

题意：给n个数，可以放到若干个盒子里，要求每个盒子至少有k个数，并且每个盒子中最大和最小的数差值不超过d。问是否有合理的方案来分配。
思路：先将所有数排序，显然数只能一段一段地放在盒子里，考虑dp。
设dp[i]，若存在方案使得1-i能放在几个盒子中，且i作为它那个盒子中最大的数，则dp[i]=1。
可以很容易想到一个朴素的dp，每次从前面的状态选一个dp[j]==1的，把j+1-i的放一个盒子中且保证这个盒子满足约束条件，即if(dp[j]==1&&i-(j+1)+1>=l&&a[i]-a[j+1]<=d)dp[i]=1  (1<=j<i) 这样的算法是n^2的
考虑根据它的三个约束条件一个个优化
1.i-(j+1)+1:这个很容易，处理出R=i-k+1,则1<=j<=R
2.a[i]-a[j+1]<=d:考虑到a是单调的，能选的j的范围随着dp过程，会越来越大，定义一个指针l，每次要更新一个新的i时，把l右移至满足条件即可，此时l<=j<=R
3.dp[j]==1:现在已处理出j能所在的区间，只要查看这范围中sigma(dp[j])若和>0，则dp[i]=1，可以用BIT维护dp[]的和。

思考：
研究好问题的单调性，这样往往能得到一个可行单调区间

8.985F

题意：给你一个长度为n的字符串， m次询问， 每次输入一个s, t, l,找到一种字母之间的映射 使的 [s,s+l-1] 与 [t,t+l-1] 里面的字符一一对应。并且只能一对一 不能一对多也不能多对一。
思路：既然是字符之间的一一映射，可以每次挑一个字母出来，hash一下它在这段中的排列，再找一下在另一段中有没有与它hash值相同的，这个判断可以把两段的hash值排个序比一下。但如果hash值暴力算没有任何意义，可以像前缀和一样存一下。

思考：
排列往往是hash的标准，对于多次区间的询问，可以考虑像前缀和一样预处理hash值

9.987D

题意：n个点，m条边，有k种商品，每个点给定生产一种商品，对于每个点，要求从k种商品中选S种，然后从附近的点搬来这S种商品，使得这样费用（每经过一条边，费用+1）最小。对于每个点输出这个最小费用。
思路：因为k<=100，多建k个点代表k种商品，对于这些点，连向那些生产这种商品的点，对每一种商品跑一次BFS即可。

思考：
对每个点开始找s个有点困难，研究数据范围，正难则反。

10.987F

题意：给出一种新的建边方式，若两点的权值&为0，则建边。给出权值范围2^n，与m个点的权值，求图中联通块的个数。

思路：
算是一种套路题吧。
尽可能的少建边，来提高效率。
考虑暴力，n^2建边肯定效率低下，因为我们只要维护连通性，像是已有1010->1，1->100，就不必1010->100。
对于权值x，现将它1,0反一下（即2^n-1-x），不妨令它为1010。那么对于0000,1000,0010,1010都可以连边，即每一位的1可以选或不选，0必须为0。考虑上述重复的边是如何产生的，像1010->1000,1000->0000,1010->0000。可以类比一下，一些状压dp的转移方式，每次只消除一个1（因为顺序对答案不产生影响，只考虑连通性），这样像1010->0000这样的边就不会产生，边数少了很多（极限为2^n*n）
最后灌水dfs求联通块即可。

思考：
尽量少建边，二进制可以类比一下状压dp的转移（充分利用信息尽可能少的转移）

11.992D

题意：
Nastya 在生日那天收到了一个大小为 n 的数组，她想知道数组存放的序列中，有多少的连续子序列满足其中所有的数的乘积是数的总和的 k 倍。请帮她得到答案。

思路：对于a[i]==1的情况，因为对multipul是没有影响的，只影响L,R。那么对于连续的区间1我们就可以跳。根据数据有multipul不会超过2e18。那么根据以上的做法，因为每次乘的数都是≥2的，第二层while循环的次数不会超过61次。复杂度为O(60*n);

思考：
充分发掘题目性质与数据范围

12.992E

题意：
有一列数，要求查询这一列数中，存不存在一个数，它前面所有数之和等于它自身的值，输出这个数的编号(存在多个，只求任意一个)。
同时要求支持修改，q个修改操作，将第i个数修改为一个新值，将每次修改后数列进行查询操作。

思路：
先不管修改。
先考虑暴力，显然是暴力扫一遍，O(n)
优化：在暴力过程中，若第i个不满足，直接就去看第i+1个了，我们能不能充分利用第i个不行的信息进行优化，通过这个状态的不可能方便的直接看出一些其他状态的不可能。
因为题意满足的东西中，sum[i-1]=val[i]，sum[i]=2*sum[i-1]，能不能利用这个东西进行倍增。
因为sum序列是单调上升的，满足条件的val[i]，一定满足sum[i]>=2*sum[j](j<=i-1)，反之就不可能满足条件。
对当前处理到第i个，若i不行，我们不必跳到i+1，可以二分一下sum[i]*2在序列中的位置跳过去，因为这之间的数不能为答案，这样复杂度有两个log，仍不够优。
因为在i与跳过去的位置中这些数，它们也可以再倍增(它们肯定不是答案)，即我们能通过它们再获取一些不可能的状态，在这里我们再优化。
考虑二分与倍增一起执行，二分到一个mid，如果它处于像刚刚说的i与跳过去的位置中（即已能证实不可能为答案），不仅修改二分的区间，而且倍增（相当于再次通过这个状态的不可能，又扩张一些已证实不可能的状态），若不处于这段位置（即还无法证实是否不可能的），只修改二分区间，而不通过它倍增。
最后二分到一个数，即使用完了之前的信息，能知道的最左边的有可能为答案的数，进行一次暴力判断，若可以则找到答案，不行则通过它再来一次倍增。
实现上列操作，只需记一下倍增的值，若sum小于这个值，就是不能满足条件的，大于就是还无法确定的。
其中二分与倍增同时进行（不为嵌套），而非之前的每一次倍增搞一次二分（为嵌套），复杂度即为倍增复杂度，log(Maxsum)。
修改的话，一个BIT维护sum即可，复杂度再套上一个q*log(n)。

思考：
从暴力优化入手，考虑没有充分利用的信息


13.994F

题意：
给n个任务，每个任务有x值与y值，同时有无限台机器，机器可以处理两个任务，其中第二个任务x值必须小于第一个x值，代价是所有机器上的第一个任务x值之和除以y值之和，求最小代价。

思路：
求分数最小，想到01分数规划。
二分求一下即可。
先排序满足x2<x1的约束，但因为相等的数存在，还要多一位状态记一下与当前x值重复的，dp(i,j,k)表示当前放到i（从后往前放），在i之前有j个x值比i大的，且没有第2个任务的机器数目（就是可以将i作为第二个任务的数目），在i之前有k个x值与i相等的（之所以记这个，是因为只有严格小于才能成为第二任务，等于不行，要先缓缓），在这种情况下(答案为r)求出的分数规划的f值(f(r)=∑valuei⋅Xi−r∗⋅∑costi⋅Xi)(Xi={0,1},01表示是否属于第一个任务)(value=x,cost=y)


14.999E
题意：
有向图。
添加最小的边数，使得从s点能抵达其他任一点。

思路：
类似无向图求联通块，答案即为联通块个数-1。
这里换成了有向图，一样有向图dfs染色一下，只要注意17行，因为是有向图，需要重复染。

